import * as PIXI from "pixi.js";
import TaggedText from "./TaggedText";
export declare type Point = {
    x: number;
    y: number;
};
export declare type Rectangle = Point & {
    width: number;
    height: number;
};
export declare type Bounds = Rectangle;
export declare type Nested<T> = T | Array<Nested<T>>;
export declare type ErrorMessageType = "warning" | "error";
export interface ErrorMessage {
    type: ErrorMessageType;
    code: string;
    message: string;
    target?: TaggedText;
}
export declare type SpriteSource = string | PIXI.Texture | HTMLCanvasElement | HTMLVideoElement;
export declare type TextureSource = string | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | PIXI.BaseTexture;
export declare type ImageSource = PIXI.Sprite | SpriteSource | TextureSource;
export declare const isSpriteSource: (s: ImageSource) => s is SpriteSource;
export declare const isBaseTexture: (s: ImageSource) => s is PIXI.BaseTexture<PIXI.Resource, PIXI.IAutoDetectOptions>;
export declare const isImageElement: (s: ImageSource) => s is HTMLImageElement;
export declare const isTextureSource: (s: ImageSource) => s is TextureSource;
export declare type FontProperty = string | number;
export declare type FontMap = Record<string, FontProperty>;
export declare type ImageSourceMap = Record<string, ImageSource>;
export declare type ImageMap = Record<string, PIXI.Sprite>;
export declare type SplitStyle = "words" | "characters";
export declare type ErrorHandler = (e: ErrorMessage) => void;
export interface TaggedTextOptions {
    debug?: boolean;
    debugConsole?: boolean;
    splitStyle?: SplitStyle;
    adjustFontBaseline?: FontMap;
    imgMap?: ImageSourceMap;
    scaleIcons?: boolean;
    skipUpdates?: boolean;
    skipDraw?: boolean;
    drawWhitespace?: boolean;
    wrapEmoji?: boolean;
    errorHandler?: ErrorHandler;
    supressConsole?: boolean;
}
export declare const IMG_REFERENCE_PROPERTY = "imgSrc";
export declare const IMG_DISPLAY_PROPERTY = "imgDisplay";
export declare enum MeasurementUnit {
    default = "px",
    px = "px",
    em = "em",
    rem = "rem",
    pt = "pt",
    pc = "pc",
    in = "in",
    cm = "cm",
    mm = "mm",
    percent = "%",
    unknown = "unknown"
}
export declare const DEFAULT_MEASUREMENT_UNIT: MeasurementUnit;
export interface MeasurementComponents {
    value: number;
    unit: MeasurementUnit;
}
export declare type MeasurementValue = string | number;
export declare type Thickness = number;
export declare type Color = string | number;
export declare type FontSize = MeasurementValue;
export declare type Fill = Color | string[] | number[] | CanvasGradient | CanvasPattern;
export declare type VAlign = "top" | "middle" | "bottom" | "baseline" | number;
export declare type AlignClassic = "left" | "right" | "center" | "justify";
export declare type Align = AlignClassic | "justify" | "justify-left" | "justify-right" | "justify-center" | "justify-all";
export declare type ImageDisplayMode = "icon" | "block" | "inline";
export declare type ImageReference = string;
export declare type ImageDimensionPercentage = string;
export declare type ImageDimension = number | string | ImageDimensionPercentage;
export declare type TextTransform = "normal" | "capitalize" | "uppercase" | "lowercase";
export declare type FontStyle = "normal" | "italic" | "oblique";
export declare type TextDecorationValue = "underline" | "overline" | "line-through";
export declare type TextDecoration = "normal" | TextDecorationValue | `${TextDecorationValue} ${TextDecorationValue}` | `${TextDecorationValue} ${TextDecorationValue} ${TextDecorationValue}`;
export interface ImageStyles {
    [IMG_REFERENCE_PROPERTY]?: ImageReference;
    [IMG_DISPLAY_PROPERTY]?: ImageDisplayMode;
    imgScale?: ImageDimensionPercentage;
    imgScaleX?: ImageDimensionPercentage;
    imgScaleY?: ImageDimensionPercentage;
    imgWidth?: ImageDimension;
    imgHeight?: ImageDimension;
}
export interface UnderlineStyle {
    underlineColor?: Color;
    underlineThickness?: Thickness;
    underlineOffset?: number;
}
export interface OverlineStyle {
    overlineColor?: Color;
    overlineThickness?: Thickness;
    overlineOffset?: number;
}
export interface LineThroughStyle {
    lineThroughColor?: Color;
    lineThroughThickness?: Thickness;
    lineThroughOffset?: number;
}
export interface TextDecorationStyles extends UnderlineStyle, OverlineStyle, LineThroughStyle {
    textDecoration?: TextDecoration;
}
export interface VerticalAlignStyles {
    valign?: VAlign;
}
export interface VerticalSpacingStyles {
    lineSpacing?: number;
    paragraphSpacing?: number;
    adjustBaseline?: number;
}
export interface FontScaleStyles {
    fontScaleWidth?: number;
    fontScaleHeight?: number;
}
export interface TextTransformStyles {
    textTransform?: TextTransform;
}
export interface TextStyleExtended extends Record<string, unknown>, Partial<Omit<PIXI.ITextStyle, "align">>, ImageStyles, TextDecorationStyles, VerticalAlignStyles, VerticalSpacingStyles, FontScaleStyles, TextTransformStyles {
    align?: Align;
    fontStyle?: FontStyle;
    fontSize?: FontSize;
}
export interface TextDecorationMetrics {
    color: Color;
    bounds: Bounds;
}
export declare type TextStyleSet = Record<string, TextStyleExtended>;
declare type TagName = string;
declare type AttributeName = string;
declare type AttributeValue = string | number;
export declare type AttributesList = Record<AttributeName, AttributeValue>;
export interface TagWithAttributes {
    tagName: string;
    attributes: AttributesList;
}
export interface TagMatchData extends TagWithAttributes {
    tag: string;
    isOpening: boolean;
    index: number;
}
export declare type TagStack = TagMatchData[];
export declare type NewlineToken = "\n";
export declare type WhitespaceToken = " " | "\t" | NewlineToken;
export declare type TextToken = string;
export declare type SpriteToken = PIXI.Sprite;
export interface CompositeToken<T extends Token = Token> {
    children: T[];
}
export declare type Token = TextToken | CompositeToken | SpriteToken;
export declare type Tokens = CompositeToken;
export interface TagToken extends CompositeToken<TagToken | TextToken> {
    tag?: TagName;
    attributes?: AttributesList;
}
export declare type TagTokens = TagToken;
export interface StyledToken extends CompositeToken<StyledToken | TextToken | SpriteToken> {
    style: TextStyleExtended;
    tags: string;
}
export declare type StyledTokens = StyledToken;
export interface IFontMetrics {
    ascent: number;
    descent: number;
    fontSize: number;
}
export interface FinalToken {
    content: TextToken | SpriteToken;
    bounds: Rectangle;
    fontProperties: IFontMetrics;
    style: TextStyleExtended;
    tags: string;
    textDecorations?: TextDecorationMetrics[];
}
export declare const createEmptyFinalToken: () => FinalToken;
export declare type WordToken = FinalToken[];
export declare type LineToken = WordToken[];
export declare type ParagraphToken = LineToken[];
export interface SpriteFinalToken extends FinalToken {
    content: SpriteToken;
}
export interface TextFinalToken extends FinalToken {
    content: TextToken;
}
export interface WhitespaceFinalToken extends TextFinalToken {
    content: WhitespaceToken;
}
export interface NewlineFinalToken extends TextFinalToken {
    content: NewlineToken;
}
export declare const isWhitespace: (s: string) => s is WhitespaceToken;
export declare const isNewline: (s: string) => s is "\n";
export declare const _isSpriteToken: (t: FinalToken) => t is SpriteFinalToken;
export declare const isSpriteToken: (nested: Nested<FinalToken>) => boolean;
export declare const _isTextToken: (t: FinalToken) => t is TextFinalToken;
export declare const isTextToken: (nested: Nested<FinalToken>) => boolean;
export declare const _isWhitespaceToken: (t: FinalToken) => t is WhitespaceFinalToken;
export declare const isWhitespaceToken: (nested: Nested<FinalToken>) => boolean;
export declare const _isNewlineToken: (t: FinalToken) => t is NewlineFinalToken;
export declare const isNewlineToken: (t?: Nested<FinalToken>) => boolean;
export declare const isNotWhitespaceToken: (input: Nested<FinalToken>) => boolean;
export declare const isEmptyObject: <T extends unknown>(a: T) => boolean;
export declare const isPixel: (s: string) => boolean;
export declare const isEm: (s: string) => boolean;
export declare const isPercent: (s: string) => boolean;
export declare const pixelToNumber: (s: string) => number;
export declare const emToNumber: (s: string) => number;
export declare const percentStringToNumber: (s: string) => number;
export declare const measurementValueToComponents: (input: MeasurementValue) => MeasurementComponents;
export {};
